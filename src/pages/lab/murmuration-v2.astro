---
import Default from "../../layouts/Default.astro";
import Link from "../../components/Link.astro";
---

<Default title="murmuration v2" description="boids with topological neighbors — each bird tracks its 7 nearest neighbors">
	<div class="space-y-5">
		<article class="space-y-3">
			<h2 class="text-muted-foreground">murmuration v2: topological neighbors</h2>
			<p class="text-sm">
				<Link href="/lab/murmuration">v1</Link> · v2
			</p>
			<p>
				real starlings don't use a fixed perception radius. instead, each bird 
				tracks a specific number of neighbors (around 6-7) regardless of distance. 
				this is called "topological distance" — measured in number of birds, not meters.
			</p>
			<p>
				this makes the flock more cohesive in sparse areas (birds track further 
				away) and prevents overcrowding in dense areas (only paying attention to 
				nearest neighbors).
			</p>
			<p>
				move your mouse — the flock still avoids you like a predator.
			</p>
		</article>

		<div id="sketch-container" class="border border-border"></div>

		<article class="space-y-3">
			<h3 class="text-muted-foreground">what changed from v1</h3>
			<ul class="space-y-1">
				<li><strong>v1:</strong> fixed 50px perception radius for all birds</li>
				<li><strong>v2:</strong> each bird tracks 7 nearest neighbors, regardless of distance</li>
			</ul>
			<p>
				this is based on 2008 research (ballerini et al.) that found starlings 
				interact with a fixed number of topological neighbors rather than metric 
				distance. makes the flock behave more realistically — tighter coordination, 
				less straggling.
			</p>
		</article>
	</div>

	<script is:inline src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.3/p5.min.js"></script>
	<script is:inline>
		window.addEventListener('load', () => {
		new p5((p) => {
			const boids = [];
			const numBoids = 150;
			const topologicalNeighbors = 7; // Track 7 nearest birds
			
			class Boid {
				constructor() {
					this.position = p.createVector(p.random(p.width), p.random(p.height));
					this.velocity = p5.Vector.random2D();
					this.velocity.setMag(p.random(2, 4));
					this.acceleration = p.createVector();
					this.maxForce = 0.2;
					this.maxSpeed = 4;
				}

				edges() {
					if (this.position.x > p.width) this.position.x = 0;
					else if (this.position.x < 0) this.position.x = p.width;
					if (this.position.y > p.height) this.position.y = 0;
					else if (this.position.y < 0) this.position.y = p.height;
				}

				// Find N nearest neighbors (topological distance)
				getNearestNeighbors(boids) {
					const distances = [];
					for (let other of boids) {
						if (other === this) continue;
						const d = p.dist(
							this.position.x,
							this.position.y,
							other.position.x,
							other.position.y
						);
						distances.push({ boid: other, distance: d });
					}
					distances.sort((a, b) => a.distance - b.distance);
					return distances.slice(0, topologicalNeighbors).map(d => d.boid);
				}

				align(neighbors) {
					let steering = p.createVector();
					if (neighbors.length === 0) return steering;
					
					for (let other of neighbors) {
						steering.add(other.velocity);
					}
					steering.div(neighbors.length);
					steering.setMag(this.maxSpeed);
					steering.sub(this.velocity);
					steering.limit(this.maxForce);
					return steering;
				}

				cohesion(neighbors) {
					let steering = p.createVector();
					if (neighbors.length === 0) return steering;
					
					for (let other of neighbors) {
						steering.add(other.position);
					}
					steering.div(neighbors.length);
					steering.sub(this.position);
					steering.setMag(this.maxSpeed);
					steering.sub(this.velocity);
					steering.limit(this.maxForce);
					return steering;
				}

				separation(neighbors) {
					let steering = p.createVector();
					if (neighbors.length === 0) return steering;
					
					for (let other of neighbors) {
						const d = p.dist(
							this.position.x,
							this.position.y,
							other.position.x,
							other.position.y
						);
						let diff = p5.Vector.sub(this.position, other.position);
						diff.div(d * d);
						steering.add(diff);
					}
					steering.div(neighbors.length);
					steering.setMag(this.maxSpeed);
					steering.sub(this.velocity);
					steering.limit(this.maxForce);
					return steering;
				}

				avoid(target) {
					let steering = p.createVector();
					let d = p.dist(
						this.position.x,
						this.position.y,
						target.x,
						target.y
					);
					if (d < 100) {
						let diff = p5.Vector.sub(this.position, target);
						diff.div(d * d);
						steering.add(diff);
						steering.setMag(this.maxSpeed * 2);
						steering.sub(this.velocity);
						steering.limit(this.maxForce * 3);
					}
					return steering;
				}

				flock(boids, predator) {
					const neighbors = this.getNearestNeighbors(boids);
					
					let alignment = this.align(neighbors);
					let cohesion = this.cohesion(neighbors);
					let separation = this.separation(neighbors);
					let avoidance = this.avoid(predator);

					this.acceleration.add(alignment);
					this.acceleration.add(cohesion);
					this.acceleration.add(separation);
					this.acceleration.add(avoidance);
				}

				update() {
					this.position.add(this.velocity);
					this.velocity.add(this.acceleration);
					this.velocity.limit(this.maxSpeed);
					this.acceleration.mult(0);
				}

				show() {
					p.strokeWeight(4);
					p.stroke(255, 255, 255, 180);
					p.point(this.position.x, this.position.y);
				}
			}

			p.setup = () => {
				const container = document.getElementById("sketch-container");
				const w = container.offsetWidth || 800;
				const h = w < 768 ? w : Math.min(600, w * 0.75);
				const canvas = p.createCanvas(w, h);
				canvas.parent("sketch-container");
				for (let i = 0; i < numBoids; i++) {
					boids.push(new Boid());
				}
			};

			p.windowResized = () => {
				const container = document.getElementById("sketch-container");
				const w = container.offsetWidth || 800;
				const h = w < 768 ? w : Math.min(600, w * 0.75);
				p.resizeCanvas(w, h);
			};

			p.draw = () => {
				p.background(20, 20, 20);
				
				const predator = p.createVector(p.mouseX, p.mouseY);
				
				for (let boid of boids) {
					boid.edges();
					boid.flock(boids, predator);
					boid.update();
					boid.show();
				}
			};
		});
		});
	</script>
</Default>
