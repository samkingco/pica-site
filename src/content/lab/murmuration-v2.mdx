---
title: murmuration v2
date: 2026-02-06
excerpt: boids with topological neighbors — each bird tracks its 7 nearest neighbors
version: 2
series: murmuration
---

import P5Sketch from "../../components/P5Sketch.astro";
import Link from "../../components/Link.astro";

## murmuration v2: topological neighbors

<Link href="/lab/murmuration-v1">v1</Link> · v2 · <Link href="/lab/murmuration-v3">v3</Link>

real starlings don't use a fixed perception radius. instead, each bird 
tracks a specific number of neighbors (around 6-7) regardless of distance. 
this is called "topological distance" — measured in number of birds, not meters.

this makes the flock more cohesive in sparse areas (birds track further 
away) and prevents overcrowding in dense areas (only paying attention to 
nearest neighbors).

move your mouse — the flock still avoids you like a predator.

<P5Sketch id="murmuration-v2" />

<script type="module">{`
const container = document.getElementById("murmuration-v2");
if (container) {
	const sketch = new p5((p) => {
		const boids = [];
		const numBoids = 150;
		const topologicalNeighbors = 7;
		
		class Boid {
			constructor() {
				this.position = p.createVector(p.random(p.width), p.random(p.height));
				this.velocity = p5.Vector.random2D();
				this.velocity.setMag(p.random(2, 4));
				this.acceleration = p.createVector();
				this.maxForce = 0.2;
				this.maxSpeed = 4;
			}

			edges() {
				if (this.position.x > p.width) this.position.x = 0;
				else if (this.position.x < 0) this.position.x = p.width;
				if (this.position.y > p.height) this.position.y = 0;
				else if (this.position.y < 0) this.position.y = p.height;
			}

			getNearestNeighbors(boids) {
				const distances = [];
				for (let other of boids) {
					if (other === this) continue;
					const d = p.dist(
						this.position.x,
						this.position.y,
						other.position.x,
						other.position.y
					);
					distances.push({ boid: other, distance: d });
				}
				distances.sort((a, b) => a.distance - b.distance);
				return distances.slice(0, topologicalNeighbors).map(d => d.boid);
			}

			align(neighbors) {
				let steering = p.createVector();
				if (neighbors.length === 0) return steering;
				
				for (let other of neighbors) {
					steering.add(other.velocity);
				}
				steering.div(neighbors.length);
				steering.setMag(this.maxSpeed);
				steering.sub(this.velocity);
				steering.limit(this.maxForce);
				return steering;
			}

			cohesion(neighbors) {
				let steering = p.createVector();
				if (neighbors.length === 0) return steering;
				
				for (let other of neighbors) {
					steering.add(other.position);
				}
				steering.div(neighbors.length);
				steering.sub(this.position);
				steering.setMag(this.maxSpeed);
				steering.sub(this.velocity);
				steering.limit(this.maxForce);
				return steering;
			}

			separation(neighbors) {
				let steering = p.createVector();
				if (neighbors.length === 0) return steering;
				
				for (let other of neighbors) {
					const d = p.dist(
						this.position.x,
						this.position.y,
						other.position.x,
						other.position.y
					);
					let diff = p5.Vector.sub(this.position, other.position);
					diff.div(d * d);
					steering.add(diff);
				}
				steering.div(neighbors.length);
				steering.setMag(this.maxSpeed);
				steering.sub(this.velocity);
				steering.limit(this.maxForce);
				return steering;
			}

			avoid(target) {
				let steering = p.createVector();
				let d = p.dist(
					this.position.x,
					this.position.y,
					target.x,
					target.y
				);
				if (d < 100) {
					let diff = p5.Vector.sub(this.position, target);
					diff.div(d * d);
					steering.add(diff);
					steering.setMag(this.maxSpeed * 2);
					steering.sub(this.velocity);
					steering.limit(this.maxForce * 3);
				}
				return steering;
			}

			flock(boids, predator) {
				const neighbors = this.getNearestNeighbors(boids);
				
				let alignment = this.align(neighbors);
				let cohesion = this.cohesion(neighbors);
				let separation = this.separation(neighbors);
				let avoidance = this.avoid(predator);

				this.acceleration.add(alignment);
				this.acceleration.add(cohesion);
				this.acceleration.add(separation);
				this.acceleration.add(avoidance);
			}

			update() {
				this.position.add(this.velocity);
				this.velocity.add(this.acceleration);
				this.velocity.limit(this.maxSpeed);
				this.acceleration.mult(0);
			}

			show() {
				p.strokeWeight(4);
				p.stroke(255, 255, 255, 180);
				p.point(this.position.x, this.position.y);
			}
		}

		p.setup = () => {
			const w = container.offsetWidth;
			const h = container.offsetHeight;
			const canvas = p.createCanvas(w, h);
			canvas.parent("murmuration-v2");
			for (let i = 0; i < numBoids; i++) {
				boids.push(new Boid());
			}
		};

		p.windowResized = () => {
			const w = container.offsetWidth;
			const h = container.offsetHeight;
			p.resizeCanvas(w, h);
		};

		p.draw = () => {
			p.background(20, 20, 20);
			const predator = p.createVector(p.mouseX, p.mouseY);
			for (let boid of boids) {
				boid.edges();
				boid.flock(boids, predator);
				boid.update();
				boid.show();
			}
		};
	}, container);

	document.addEventListener('astro:before-swap', () => {
		if (sketch && sketch.remove) sketch.remove();
	}, { once: true });
}
`}</script>

### what changed from v1

- **v1:** fixed 50px perception radius for all birds
- **v2:** each bird tracks 7 nearest neighbors, regardless of distance

this is based on 2008 research (ballerini et al.) that found starlings 
interact with a fixed number of topological neighbors rather than metric 
distance. makes the flock behave more realistically — tighter coordination, 
less straggling.
