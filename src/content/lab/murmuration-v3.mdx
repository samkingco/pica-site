---
title: "murmuration v3: dynamic interaction"
date: 2026-02-06
excerpt: "interactive influence — mouse becomes friend or foe based on movement"
version: 3
series: murmuration
---

import P5Sketch from "../../components/P5Sketch.astro";
import Link from "../../components/Link.astro";

## murmuration v3: dynamic interaction

instead of the mouse always being a predator, it now responds to how you move:

- **move slowly** → birds are attracted (curious friend)
- **move quickly** → birds flee (threat/predator)
- **stay still** → birds lose interest, return to natural flocking

this lets you see both the natural murmuration patterns and how you can influence the flock through movement.

<P5Sketch id="murmuration-v3" />

<script type="module">{`
const container = document.getElementById("murmuration-v3");
if (container) {
	const sketch = new p5((p) => {
		const boids = [];
		const numBoids = 150;
		const topologicalNeighbors = 7;
		let prevMouseX = 0;
		let prevMouseY = 0;
		let mouseSpeed = 0;
		
		class Boid {
			constructor() {
				this.position = p.createVector(p.random(p.width), p.random(p.height));
				this.velocity = p5.Vector.random2D();
				this.velocity.setMag(p.random(2, 4));
				this.acceleration = p.createVector();
				this.maxForce = 0.2;
				this.maxSpeed = 4;
			}

			edges() {
				if (this.position.x > p.width) this.position.x = 0;
				else if (this.position.x < 0) this.position.x = p.width;
				if (this.position.y > p.height) this.position.y = 0;
				else if (this.position.y < 0) this.position.y = p.height;
			}

			getNearestNeighbors(boids) {
				const distances = [];
				for (let other of boids) {
					if (other === this) continue;
					const d = p.dist(
						this.position.x,
						this.position.y,
						other.position.x,
						other.position.y
					);
					distances.push({ boid: other, distance: d });
				}
				distances.sort((a, b) => a.distance - b.distance);
				return distances.slice(0, topologicalNeighbors).map(d => d.boid);
			}

			align(neighbors) {
				let steering = p.createVector();
				if (neighbors.length === 0) return steering;
				
				for (let other of neighbors) {
					steering.add(other.velocity);
				}
				steering.div(neighbors.length);
				steering.setMag(this.maxSpeed);
				steering.sub(this.velocity);
				steering.limit(this.maxForce);
				return steering;
			}

			cohesion(neighbors) {
				let steering = p.createVector();
				if (neighbors.length === 0) return steering;
				
				for (let other of neighbors) {
					steering.add(other.position);
				}
				steering.div(neighbors.length);
				steering.sub(this.position);
				steering.setMag(this.maxSpeed);
				steering.sub(this.velocity);
				steering.limit(this.maxForce);
				return steering;
			}

			separation(neighbors) {
				let steering = p.createVector();
				if (neighbors.length === 0) return steering;
				
				for (let other of neighbors) {
					const d = p.dist(
						this.position.x,
						this.position.y,
						other.position.x,
						other.position.y
					);
					let diff = p5.Vector.sub(this.position, other.position);
					diff.div(d * d);
					steering.add(diff);
				}
				steering.div(neighbors.length);
				steering.setMag(this.maxSpeed);
				steering.sub(this.velocity);
				steering.limit(this.maxForce);
				return steering;
			}

			interact(target, speed) {
				let steering = p.createVector();
				let d = p.dist(
					this.position.x,
					this.position.y,
					target.x,
					target.y
				);
				
				// Speed threshold: slow movement = attraction, fast = avoidance
				const speedThreshold = 10;
				const influenceRadius = 150;
				
				if (d < influenceRadius && speed > 0.5) {
					if (speed < speedThreshold) {
						// Slow movement - attraction (curious)
						let diff = p5.Vector.sub(target, this.position);
						diff.setMag(this.maxSpeed * 0.5);
						steering = diff.sub(this.velocity);
						steering.limit(this.maxForce * 0.8);
					} else {
						// Fast movement - avoidance (threat)
						let diff = p5.Vector.sub(this.position, target);
						diff.div(d * d);
						steering.add(diff);
						steering.setMag(this.maxSpeed * 2);
						steering.sub(this.velocity);
						steering.limit(this.maxForce * 3);
					}
				}
				// If still or far away, no interaction
				return steering;
			}

			flock(boids, target, speed) {
				const neighbors = this.getNearestNeighbors(boids);
				
				let alignment = this.align(neighbors);
				let cohesion = this.cohesion(neighbors);
				let separation = this.separation(neighbors);
				let interaction = this.interact(target, speed);

				this.acceleration.add(alignment);
				this.acceleration.add(cohesion);
				this.acceleration.add(separation);
				this.acceleration.add(interaction);
			}

			update() {
				this.position.add(this.velocity);
				this.velocity.add(this.acceleration);
				this.velocity.limit(this.maxSpeed);
				this.acceleration.mult(0);
			}

			show() {
				p.strokeWeight(4);
				p.stroke(255, 255, 255, 180);
				p.point(this.position.x, this.position.y);
			}
		}

		p.setup = () => {
			const w = container.offsetWidth;
			const h = container.offsetHeight;
			const canvas = p.createCanvas(w, h);
			canvas.parent("murmuration-v3");
			for (let i = 0; i < numBoids; i++) {
				boids.push(new Boid());
			}
			prevMouseX = p.mouseX;
			prevMouseY = p.mouseY;
		};

		p.windowResized = () => {
			const w = container.offsetWidth;
			const h = container.offsetHeight;
			p.resizeCanvas(w, h);
		};

		p.draw = () => {
			p.background(20, 20, 20);
			
			// Calculate mouse speed
			const dx = p.mouseX - prevMouseX;
			const dy = p.mouseY - prevMouseY;
			mouseSpeed = p.sqrt(dx * dx + dy * dy);
			prevMouseX = p.mouseX;
			prevMouseY = p.mouseY;
			
			const mouse = p.createVector(p.mouseX, p.mouseY);
			
			for (let boid of boids) {
				boid.edges();
				boid.flock(boids, mouse, mouseSpeed);
				boid.update();
				boid.show();
			}
		};
	}, container);

	document.addEventListener('astro:before-swap', () => {
		if (sketch && sketch.remove) sketch.remove();
	}, { once: true });
}
`}</script>

### what changed from v2

- **v1:** mouse always avoids (predator)
- **v2:** topological neighbors (7 nearest)
- **v3:** mouse interaction depends on speed
  - slow movement → birds attracted (curious, treating you as friend)
  - fast movement → birds flee (threat response)
  - no movement → birds ignore you, natural flocking resumes

this makes the interaction more nuanced and lets you see the difference between natural murmuration behavior and influenced patterns. try moving your mouse slowly through the flock vs. quick movements.
