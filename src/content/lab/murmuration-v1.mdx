---
title: "murmuration v1: basic boids"
date: 2026-02-06
excerpt: "basic boids algorithm - each bird follows three simple rules"
version: 1
series: murmuration
---

import P5Sketch from "../../components/P5Sketch.astro";
import Link from "../../components/Link.astro";

## murmuration v1: basic boids

a flocking simulation based on craig reynolds' boids algorithm (1986). 
each bird follows three simple rules: maintain distance from neighbors, 
match their direction, and move toward the group center.

move your mouse over the canvas — the flock avoids you like a predator.

<P5Sketch id="murmuration-v1" />

<script type="module">{`
const container = document.getElementById("murmuration-v1");
if (container) {
	const sketch = new p5((p) => {
		const boids = [];
		const numBoids = 150;
		
		class Boid {
			constructor() {
				this.position = p.createVector(p.random(p.width), p.random(p.height));
				this.velocity = p5.Vector.random2D();
				this.velocity.setMag(p.random(2, 4));
				this.acceleration = p.createVector();
				this.maxForce = 0.2;
				this.maxSpeed = 4;
				this.perceptionRadius = 50;
			}

			edges() {
				if (this.position.x > p.width) this.position.x = 0;
				else if (this.position.x < 0) this.position.x = p.width;
				if (this.position.y > p.height) this.position.y = 0;
				else if (this.position.y < 0) this.position.y = p.height;
			}

			align(boids) {
				let steering = p.createVector();
				let total = 0;
				for (let other of boids) {
					let d = p.dist(
						this.position.x,
						this.position.y,
						other.position.x,
						other.position.y
					);
					if (other !== this && d < this.perceptionRadius) {
						steering.add(other.velocity);
						total++;
					}
				}
				if (total > 0) {
					steering.div(total);
					steering.setMag(this.maxSpeed);
					steering.sub(this.velocity);
					steering.limit(this.maxForce);
				}
				return steering;
			}

			cohesion(boids) {
				let steering = p.createVector();
				let total = 0;
				for (let other of boids) {
					let d = p.dist(
						this.position.x,
						this.position.y,
						other.position.x,
						other.position.y
					);
					if (other !== this && d < this.perceptionRadius) {
						steering.add(other.position);
						total++;
					}
				}
				if (total > 0) {
					steering.div(total);
					steering.sub(this.position);
					steering.setMag(this.maxSpeed);
					steering.sub(this.velocity);
					steering.limit(this.maxForce);
				}
				return steering;
			}

			separation(boids) {
				let steering = p.createVector();
				let total = 0;
				for (let other of boids) {
					let d = p.dist(
						this.position.x,
						this.position.y,
						other.position.x,
						other.position.y
					);
					if (other !== this && d < this.perceptionRadius) {
						let diff = p5.Vector.sub(this.position, other.position);
						diff.div(d * d);
						steering.add(diff);
						total++;
					}
				}
				if (total > 0) {
					steering.div(total);
					steering.setMag(this.maxSpeed);
					steering.sub(this.velocity);
					steering.limit(this.maxForce);
				}
				return steering;
			}

			avoid(target) {
				let steering = p.createVector();
				let d = p.dist(
					this.position.x,
					this.position.y,
					target.x,
					target.y
				);
				if (d < 100) {
					let diff = p5.Vector.sub(this.position, target);
					diff.div(d * d);
					steering.add(diff);
					steering.setMag(this.maxSpeed * 2);
					steering.sub(this.velocity);
					steering.limit(this.maxForce * 3);
				}
				return steering;
			}

			flock(boids, predator) {
				let alignment = this.align(boids);
				let cohesion = this.cohesion(boids);
				let separation = this.separation(boids);
				let avoidance = this.avoid(predator);

				this.acceleration.add(alignment);
				this.acceleration.add(cohesion);
				this.acceleration.add(separation);
				this.acceleration.add(avoidance);
			}

			update() {
				this.position.add(this.velocity);
				this.velocity.add(this.acceleration);
				this.velocity.limit(this.maxSpeed);
				this.acceleration.mult(0);
			}

			show() {
				p.strokeWeight(4);
				p.stroke(255, 255, 255, 180);
				p.point(this.position.x, this.position.y);
			}
		}

		p.setup = () => {
			const w = container.offsetWidth;
			const h = container.offsetHeight;
			const canvas = p.createCanvas(w, h);
			canvas.parent("murmuration-v1");
			for (let i = 0; i < numBoids; i++) {
				boids.push(new Boid());
			}
		};

		p.windowResized = () => {
			const w = container.offsetWidth;
			const h = container.offsetHeight;
			p.resizeCanvas(w, h);
		};

		p.draw = () => {
			p.background(20, 20, 20);
			const predator = p.createVector(p.mouseX, p.mouseY);
			for (let boid of boids) {
				boid.edges();
				boid.flock(boids, predator);
				boid.update();
				boid.show();
			}
		};
	}, container);

	document.addEventListener('astro:before-swap', () => {
		if (sketch && sketch.remove) sketch.remove();
	}, { once: true });
}
`}</script>

### about boids

starling murmurations are one of nature's most striking examples of 
emergent behavior. thousands of birds moving as one fluid mass, never 
colliding, responding instantly to threats.

the boids model shows how complex global patterns emerge from simple 
local rules. no leader, no central coordination. just individual birds 
paying attention to their neighbors.

this version uses a fixed 50px perception radius — simple but not quite 
how real starlings work. they track specific neighbors regardless of 
distance. see <Link href="/lab/murmuration-v2">v2</Link> for topological 
neighbors based on actual starling research.
